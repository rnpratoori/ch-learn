import numpy as np
import matplotlib.pyplot as plt
import sys
from pathlib import Path
import argparse

# Assuming plotting.py is in the same directory or accessible
from plotting import plot_combined_final_timestep, plot_loss_vs_epochs

def plot_nn_output_vs_c_from_data(c_values, nn_output_values, ylabel, title, output_path):
    """
    Plots nn output vs c from saved data.
    """
    try:
        fig, ax = plt.subplots(figsize=(6, 4))
        ax.plot(c_values, nn_output_values)
        ax.set_xlabel("Concentration (c)")
        ax.set_ylabel(ylabel)
        ax.set_title(title)
        ax.grid(True)
        plt.tight_layout()
        fig.savefig(output_path)
        plt.close(fig)
        print(f"Saved nn output plot to {output_path}")
    except Exception as e:
        print(f"Could not create nn output vs c plot: {e}")

def plot_multi_timestep_comparison_2d_from_data(epoch, comparison_data, output_path):
    """
    Creates a 2D figure with predictions and targets at multiple timesteps on the same plot from saved data.
    """
    num_plots = len(comparison_data)
    if num_plots == 0:
        return

    fig, ax = plt.subplots(figsize=(10, 6))
    
    colors = plt.cm.viridis(np.linspace(0, 1, num_plots))

    for i, (timestep, pred_np, target_np) in enumerate(comparison_data):
        x = np.arange(pred_np.size)
        ax.plot(x, pred_np, label=f'Pred (t={timestep + 1})', color=colors[i])
        ax.plot(x, target_np, label=f'Targ (t={timestep + 1})', color=colors[i], linestyle='--')

    ax.set_xlabel("DOF index")
    ax.set_ylabel("c")
    ax.set_title(f"Epoch {epoch} - 2D Multi-timestep Comparison (from saved data)")
    ax.legend(ncol=2, fontsize='small')
    ax.grid(True)
    plt.tight_layout()
    fig.savefig(output_path)
    plt.close(fig)
    print(f"Saved 2D multi-timestep comparison plot to {output_path}")

def plot_multi_timestep_comparison_3d_from_data(epoch, comparison_data, output_path):
    """
    Creates a 3D figure with predictions and targets at multiple timesteps from saved data.
    """
    if len(comparison_data) == 0:
        return

    fig = plt.figure(figsize=(12, 8))
    ax = fig.add_subplot(111, projection='3d')

    # Prepare data for surface plots
    x_coords = np.arange(comparison_data[0][1].size)
    t_coords = np.array([d[0] for d in comparison_data])
    
    X, T = np.meshgrid(x_coords, t_coords)
    
    C_pred = np.array([d[1] for d in comparison_data])
    C_targ = np.array([d[2] for d in comparison_data])

    # Plot the prediction and target surfaces
    ax.plot_surface(X, T, C_pred, cmap='viridis', alpha=0.7, rstride=1, cstride=5, label='Prediction')
    ax.plot_surface(X, T, C_targ, cmap='autumn', alpha=0.7, rstride=1, cstride=5, label='Target')

    ax.set_xlabel("DOF index")
    ax.set_ylabel("Timestep")
    ax.set_zlabel("Concentration (c)")
    ax.set_title(f"Epoch {epoch} - 3D Space-Time Comparison (from saved data)")
    
    # Create proxy artists for legend
    pred_proxy = plt.Rectangle((0, 0), 1, 1, fc="blue")
    targ_proxy = plt.Rectangle((0, 0), 1, 1, fc="red")
    ax.legend([pred_proxy, targ_proxy], ['Prediction', 'Target'])

    plt.tight_layout()
    fig.savefig(output_path)
    plt.close(fig)
    print(f"Saved 3D multi-timestep comparison plot to {output_path}")


def reproduce_plots(npz_path):
    """
    Loads data from an .npz file and reproduces the plots generated by ch_learn.py.
    """
    npz_path = Path(npz_path)
    if not npz_path.is_file():
        print(f"Error: File not found at {npz_path}")
        return

    # Create output directory for plots
    plot_output_dir = npz_path.parent / "reproduced_plots"
    plot_output_dir.mkdir(exist_ok=True)
    print(f"Saving plots to {plot_output_dir}")

    data = np.load(npz_path, allow_pickle=True)

    # --- Find min loss epoch ---
    min_loss_idx = -1
    min_loss_epoch = -1
    if 'epoch_losses' in data and len(data['epoch_losses']) > 0:
        min_loss_idx = np.argmin(data['epoch_losses'])
        if 'epoch_numbers' in data:
            min_loss_epoch = data['epoch_numbers'][min_loss_idx]
            print(f"\nMinimum loss of {data['epoch_losses'][min_loss_idx]} found at epoch {min_loss_epoch}.")
        else:
            # Fallback if epoch_numbers is not there for some reason
            min_loss_epoch = min_loss_idx + 1
            print(f"\nMinimum loss of {data['epoch_losses'][min_loss_idx]} found at index {min_loss_idx} (epoch number may vary).")
    else:
        print("\nLoss data not found, cannot determine minimum loss epoch.")


    # --- 1. Plot combined final timestep ---
    print("Generating combined final timestep plot...")
    if 'preds_collection' in data and 'epochs_collection' in data and 'target_final_global' in data:
        combined_fig = plot_combined_final_timestep(
            data['preds_collection'],
            data['epochs_collection'],
            data['target_final_global']
        )
        if combined_fig:
            combined_fig.savefig(plot_output_dir / "combined_final_timestep.png")
            plt.close(combined_fig)
            print(f"Saved combined final timestep plot.")
    else:
        print("Skipping combined final timestep plot: Data not found in .npz file.")

    # --- Generate plots for min loss epoch ---
    if min_loss_epoch != -1:
        print(f"\nGenerating additional plots for minimum loss epoch {min_loss_epoch}...")

        # --- 1a. Plot combined final timestep for min loss epoch ---
        if 'preds_collection' in data and 'epochs_collection' in data:
            epoch_in_collection_idx = np.where(data['epochs_collection'] == min_loss_epoch)[0]
            if len(epoch_in_collection_idx) > 0:
                idx = epoch_in_collection_idx[0]
                print("Generating combined final timestep plot for min loss epoch...")
                min_loss_fig = plot_combined_final_timestep(
                    [data['preds_collection'][idx]],
                    [data['epochs_collection'][idx]],
                    data['target_final_global']
                )
                if min_loss_fig:
                    min_loss_fig.savefig(plot_output_dir / f"combined_final_timestep_min_loss_epoch_{min_loss_epoch}.png")
                    plt.close(min_loss_fig)
                    print(f"Saved combined final timestep plot for min loss epoch.")
            else:
                print("Could not find prediction data for min loss epoch in preds_collection.")

        # --- 2a. Note about nn_output_vs_c for min loss ---
        print("Note: The nn_output_vs_c plot is generated for the final model state, as intermediate model states are not saved in the .npz file.")


    # --- 2. Plot nn output vs c ---
    print("\nGenerating nn output vs c plot (for final model state)...")
    if 'c_values_nn' in data and 'nn_output_values' in data and 'nn_output_label' in data:
        ylabel = str(data['nn_output_label'])
        title = f"Learned {ylabel} vs. Concentration (Final Epoch)"
        plot_nn_output_vs_c_from_data(
            data['c_values_nn'],
            data['nn_output_values'],
            ylabel,
            title,
            plot_output_dir / "nn_output_vs_c.png"
        )
    else:
        print("Skipping nn output plot: Data not found in .npz file.")

    # --- 3. Plot loss vs epochs ---
    print("\nGenerating loss vs epochs plot...")
    if 'epoch_losses' in data and 'epoch_numbers' in data:
        plot_loss_vs_epochs(
            data['epoch_numbers'],
            data['epoch_losses'],
            plot_output_dir / "loss_vs_epochs.png"
        )
    else:
        print("Skipping loss plot: Data not found in .npz file.")

    # --- 4. Plot multi-timestep comparisons ---
    print("\nGenerating multi-timestep comparison plots...")
    if 'all_epochs_comparison_data' in data:
        all_epochs_data = data['all_epochs_comparison_data']
        
        # Try to determine total epochs from the data for frequency calculation
        num_epochs_from_data = 0
        if 'epoch_numbers' in data and len(data['epoch_numbers']) > 0:
            num_epochs_from_data = data['epoch_numbers'][-1]
        elif len(all_epochs_data) > 0:
            num_epochs_from_data = all_epochs_data[-1]['epoch'] + 1

        # Recreate the frequencies from ch_learn.py if possible
        video_frame_save_freq = 1
        if num_epochs_from_data > 0:
            video_frame_save_freq = max(1, num_epochs_from_data // 100)
        
        for epoch_data in all_epochs_data:
            epoch = epoch_data['epoch']
            
            plot_now = False
            # Plot if it's a video frame, the last epoch, or the min loss epoch
            if (epoch + 1) % video_frame_save_freq == 0:
                plot_now = True
            if num_epochs_from_data > 0 and (epoch + 1) == num_epochs_from_data:
                plot_now = True
            if (epoch + 1) == min_loss_epoch:
                plot_now = True

            if plot_now:
                filename_suffix = f"_epoch_{epoch+1}"
                if (epoch + 1) == min_loss_epoch:
                    filename_suffix = f"_min_loss_epoch_{epoch+1}"

                plot_multi_timestep_comparison_2d_from_data(
                    epoch + 1,
                    epoch_data['data'],
                    plot_output_dir / f"multi_ts_comparison_2d{filename_suffix}.png"
                )
                plot_multi_timestep_comparison_3d_from_data(
                    epoch + 1,
                    epoch_data['data'],
                    plot_output_dir / f"multi_ts_comparison_3d{filename_suffix}.png"
                )
    else:
        print("Skipping multi-timestep plots: Data not found in .npz file.")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Reproduce plots from ch_learn.py's .npz output.")
    parser.add_argument("npz_file", type=str, help="Path to the post_processing_data.npz file.")
    args = parser.parse_args()

    reproduce_plots(args.npz_file)
